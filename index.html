<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MC Skin Architect Pro</title>
    <style>
        :root { --accent: #00ff88; --bg: #0f0f0f; --panel: #1a1a1a; }
        body { margin: 0; background: var(--bg); color: white; font-family: 'Segoe UI', sans-serif; display: flex; height: 100vh; overflow: hidden; }
        #toolbar { width: 300px; background: var(--panel); padding: 20px; border-right: 1px solid #333; display: flex; flex-direction: column; gap: 15px; z-index: 10; }
        #canvas-container { flex-grow: 1; position: relative; }
        @media (max-width: 768px) {
            body { flex-direction: column; }
            #toolbar { width: 100%; height: auto; border-right: none; border-top: 1px solid #333; order: 2; padding: 15px; }
            #canvas-container { height: 60vh; order: 1; }
        }
        h1 { font-size: 1.1rem; margin: 0; color: var(--accent); text-transform: uppercase; letter-spacing: 2px; }
        .group { display: flex; flex-direction: column; gap: 5px; border-bottom: 1px solid #333; padding-bottom: 15px; }
        label { font-size: 0.7rem; color: #888; text-transform: uppercase; font-weight: bold; }
        input, select, button { background: #252525; border: 1px solid #444; color: white; padding: 10px; border-radius: 4px; font-size: 0.85rem; }
        button { background: var(--accent); color: black; font-weight: bold; border: none; cursor: pointer; }
        .secondary { background: #444; color: white; }
    </style>
</head>
<body>

<div id="toolbar">
    <h1>Skin Architect</h1>
    <div class="group">
        <label>Import Skin</label>
        <input type="text" id="username" placeholder="Username">
        <button id="fetchBtn">FETCH SKIN</button>
        <input type="file" id="fileInput" accept="image/png" style="font-size: 0.6rem;">
    </div>
    <div class="group">
        <label>Model Mode</label>
        <select id="modelMode">
            <option value="full">Full Body</option>
            <option value="head">Head Only</option>
        </select>
    </div>
    <div class="group">
        <label>Extrusion Depth</label>
        <input type="range" id="depthRange" min="0.02" max="0.30" step="0.01" value="0.12">
    </div>
    <div class="group">
        <label>Color Export</label>
        <select id="exportFormat">
            <option value="glb">GLB (Auto-Color Slicers)</option>
            <option value="stl">STL (No Color)</option>
        </select>
        <button id="exportBtn" class="secondary">DOWNLOAD FOR SLICER</button>
        <div id="status" style="font-size: 0.7rem; color: var(--accent);">Ready</div>
    </div>
</div>

<div id="canvas-container"></div>

<script type="module">
    import * as THREE from 'https://cdn.skypack.dev/three@0.132.2';
    import { OrbitControls } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/controls/OrbitControls.js';
    import { STLExporter } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/exporters/STLExporter.js';
    import { GLTFExporter } from 'https://cdn.skypack.dev/three@0.132.2/examples/jsm/exporters/GLTFExporter.js';

    const container = document.getElementById('canvas-container');
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(50, container.clientWidth / container.clientHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    container.appendChild(renderer.domElement);

    const controls = new OrbitControls(camera, renderer.domElement);
    camera.position.set(3, 2, 5);
    scene.add(new THREE.AmbientLight(0xffffff, 1.0));

    const mainGroup = new THREE.Group();
    scene.add(mainGroup);

    let currentImg = null;

    function getMat(img, x, y, w, h) {
        const c = document.createElement('canvas');
        c.width = w; c.height = h;
        const ctx = c.getContext('2d');
        ctx.drawImage(img, x, y, w, h, 0, 0, w, h);
        const t = new THREE.CanvasTexture(c);
        t.magFilter = THREE.NearestFilter;
        return new THREE.MeshStandardMaterial({ map: t, roughness: 1 });
    }

    function createPart(img, w, h, d, uv, pos, overlayUv) {
        const partGroup = new THREE.Group();
        const depth = parseFloat(document.getElementById('depthRange').value);

        const mats = [
            getMat(img, uv.x+d+w, uv.y+d, d, h), getMat(img, uv.x, uv.y+d, d, h),
            getMat(img, uv.x+d, uv.y, w, d), getMat(img, uv.x+d+w, uv.y, w, d),
            getMat(img, uv.x+d, uv.y+d, w, h), getMat(img, uv.x+d*2+w, uv.y+d, w, h)
        ];
        partGroup.add(new THREE.Mesh(new THREE.BoxGeometry(w/8, h/8, d/8), mats));

        if (overlayUv) {
            const tempCanvas = document.createElement('canvas');
            const tCtx = tempCanvas.getContext('2d');
            tCtx.drawImage(img, 0, 0);
            const data = tCtx.getImageData(overlayUv.x+d, overlayUv.y+d, w, h).data;
            for(let i=0; i<(w*h); i++) {
                if(data[i*4+3] > 10) {
                    const vox = new THREE.Mesh(
                        new THREE.BoxGeometry(1/8, 1/8, depth),
                        new THREE.MeshStandardMaterial({ color: new THREE.Color(`rgb(${data[i*4]},${data[i*4+1]},${data[i*4+2]})`), roughness: 1 })
                    );
                    let px = i%w, py = Math.floor(i/w);
                    vox.position.set((px/8)-(w/16)+0.0625, (h/16)-(py/8)-0.0625, (d/16)+(depth/2));
                    partGroup.add(vox);
                }
            }
        }
        partGroup.position.set(pos.x, pos.y, pos.z);
        mainGroup.add(partGroup);
    }

    function buildModel() {
        if(!currentImg) return;
        mainGroup.clear();
        const mode = document.getElementById('modelMode').value;
        if(mode === 'head') {
            createPart(currentImg, 8, 8, 8, {x:0, y:0}, {x:0, y:0, z:0}, {x:32, y:0});
        } else {
            createPart(currentImg, 8, 8, 8, {x:0, y:0}, {x:0, y:1.25, z:0}, {x:32, y:0});
            createPart(currentImg, 8, 12, 4, {x:16, y:16}, {x:0, y:0, z:0}, {x:16, y:32});
            createPart(currentImg, 4, 12, 4, {x:40, y:16}, {x:-0.75, y:0, z:0}, {x:40, y:32});
            createPart(currentImg, 4, 12, 4, {x:32, y:48}, {x:0.75, y:0, z:0}, {x:48, y:48});
            createPart(currentImg, 4, 12, 4, {x:0, y:16}, {x:-0.25, y:-1.5, z:0}, {x:0, y:32});
            createPart(currentImg, 4, 12, 4, {x:16, y:48}, {x:0.25, y:-1.5, z:0}, {x:0, y:48});
        }
    }

    document.getElementById('fetchBtn').onclick = () => {
        const user = document.getElementById('username').value;
        const img = new Image();
        img.crossOrigin = "Anonymous";
        img.onload = () => { currentImg = img; buildModel(); };
        img.src = `https://mc-heads.net/skin/${user}`;
    };

    document.getElementById('fileInput').onchange = (e) => {
        const reader = new FileReader();
        reader.onload = (ev) => {
            const img = new Image();
            img.onload = () => { currentImg = img; buildModel(); };
            img.src = ev.target.result;
        };
        reader.readAsDataURL(e.target.files[0]);
    };

    document.getElementById('modelMode').onchange = buildModel;
    document.getElementById('depthRange').oninput = buildModel;

    document.getElementById('exportBtn').onclick = () => {
        const format = document.getElementById('exportFormat').value;
        if(format === 'stl') {
            const exporter = new STLExporter();
            save(new Blob([exporter.parse(mainGroup, {binary:true})], {type:'application/octet-stream'}), 'skin.stl');
        } else {
            const exporter = new GLTFExporter();
            exporter.parse(mainGroup, (res) => {
                save(new Blob([JSON.stringify(res)], {type:'application/json'}), 'skin.gltf');
            });
        }
    };

    function save(blob, name) {
        const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = name; a.click();
    }

    function animate() {
        requestAnimationFrame(animate);
        mainGroup.rotation.y += 0.005;
        renderer.render(scene, camera);
    }
    animate();

    window.onresize = () => {
        camera.aspect = container.clientWidth / container.clientHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(container.clientWidth, container.clientHeight);
    };
</script>
</body>
</html>
